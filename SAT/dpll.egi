;;
;; DPLL with backjumping and learning
;;

(define $assignment
  (matcher
    {[<deduced $> [integer]
      {[<Deduced $l> {l}]
       [_ {}]}]
     [<guessed $> [integer]
      {[<Guessed $l> {l}]
       [_ {}]}]
     [<whichever $> [integer]
      {[<Deduced $l> {l}]
       [<Guessed $l> {l}]}]
     [$ [something]
      {[$tgt {tgt}]}]}))

(define $guessed
  (lambda [$trail]
    (match-all trail (list assignment)
      [<join _ <cons <guessed $l> _>> l])))

(define $deduced
  (lambda [$trail]
    (match-all trail (list assignment)
      [<join _ <cons <deduced $l> _>> l])))

(define $delete-literal
  (lambda [$l $cnf]
    (map (lambda [$c] (match-all c (multiset integer)
                        [<cons (and !,l $x) _> x]))
         cnf)))

(define $delete-clauses-with
  (lambda [$l $cnf]
    (match-all cnf (multiset (multiset integer))
      [<cons (& !<cons ,l _> $c) _> c])))

(define $assign-true
  (lambda [$l $cnf]
    (delete-literal (neg l) (delete-clauses-with l cnf))))

(define $unit-propagate''
  (lambda [$cnf $trail]
    (match cnf (multiset (multiset integer))
      {[<cons <nil> _> [cnf trail]]
       [<cons <cons $l <nil>> _> (unit-propagate'' (assign-true l cnf) {<Deduced l> @trail})]
       [<cons <cons $l _> !<cons <cons ,(neg l) _> _>> (unit-propagate'' (assign-true l cnf) {<Deduced l> @trail})]
       [_ [cnf trail]]
       })))

(define $unit-propagate'
  (lambda [$cnf $trail' $trail]
    (match trail' (list assignment)
      {[<cons <whichever $l> $trail'> (unit-propagate' (assign-true l cnf) trail' trail)]
       [_ (unit-propagate'' cnf trail)]
       })))

(define $unit-propagate
  (lambda [$cnf $trail]
    (unit-propagate' cnf trail trail)))

(define $conflict?
  (lambda [$cnf $trail]
    (match (2#%1 (unit-propagate cnf {})) (multiset (multiset integer))
      {[<cons <nil> _> #t]
       [_ #f]})))

(define $backjump
  (lambda [$cnf $p $trail]
    (match trail (list assignment)
      {[<join _ (& <cons <guessed $l> $trail''> $trail')>
        (if (conflict? cnf {<Guessed p> @trail''})
          (backjump cnf p trail'')
          trail')]
       [_ trail]})))

(define $dplb'
  (lambda [$cnf $trail]
    (let {[[$cnf' $trail] (unit-propagate cnf trail)]}
      (match [cnf' trail] [(multiset (multiset integer)) (multiset assignment)]
        {[[<nil> _] [#t trail]]
         [[<cons <nil> _> _]
          (match trail (list assignment)
            {[<join _ <cons <guessed $l> $trail'>>
              (let {[$trail'' (backjump cnf l trail')]}
                (dplb' {(map neg {l @(guessed trail'')}) @cnf} {<Deduced (neg l)> @trail''}))]
             [_ #f]})]
         [[<cons <cons $l _> _> !(| <cons <whichever ,l> _>
                                    <cons <whichever ,(neg l)> _>)]
          (dplb' cnf {<Guessed l> @trail})]
         }))))

(define $dplb
  (lambda [$cnf]
    (dplb' cnf {})))

"dplb start"
(dplb {{1}}) ; [#t {<Deduced 1>}]
(dplb {{1} {-1}}) ; #f
(dplb {{1 2} {-1 3} {1 -3}}) ; [#t {<Deduced -3> <Guessed -1> <Deduced 2>}]
(dplb {{1 2} {-1 -2} {1 -2}}) ; [#t {<Deduced -2> <Guessed 1>}]
(dplb {{1 2} {-1 -2} {1 -2} {-1 2}}) ; #f
(dplb {{-1 -2 3} {-1 -2 -3} {1 2 3 4} {-4 -2 3} {5 1 2 -3} {-3 1 -5} {1 -2 3 4} {1 -2 -3 5}}) ; [#t {<Deduced -3> <Deduced 4> <Deduced -2> <Guessed -1>}]
"dplb end"
